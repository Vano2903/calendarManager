package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"text/template"
	"time"

	resp "github.com/vano2903/calendarManager/responser"
)

type HandlerHttp struct {
	oauther  *Oauther
	sheeter  *Sheeter
	calender *Calender
}

//!========== MIDDLEWARES

/*
this middleware validates if the users has a valid access token
what it does/check:
1)  if the refresh token is found (if not it will redirect to the oauth server)
2)  if the refresh token is expired
3)  if the access token is found/valid, since this runs after the check of the refresh token
	the middleware will generate a new pair of tokens if the access token is expired/not found and
	save them in the session
4)  if the oauther client is set
	in case it's not set it will create the sheeter and
	calender struct since they are based on the oauther client
5)  if it pass all the check it will run the func given as parameter
!this middleware only validates the token pair generated by the server, not the google one
*/
func (h *HandlerHttp) AccessTokenMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// get the access token and the refresh token from cookies
		var accessToken string
		var refreshToken string
		for _, cookie := range r.Cookies() {
			switch cookie.Name {
			case "accessToken":
				accessToken = cookie.Value
			case "refreshToken":
				refreshToken = cookie.Value
			}
		}

		//if refresh token is not found redirect to oauth endpoint
		if refreshToken == "" {
			resp.Error(w, http.StatusBadRequest, "No refresh token, you should visit the oauth page")
			return
		}

		//create a connection with the db
		db, err := connectToDB()
		if err != nil {
			resp.Error(w, http.StatusInternalServerError, err.Error())
			return
		}
		defer db.Close()

		//check if the refresh token is expired
		if IsTokenExpired(false, refreshToken, db) {
			//!should redirect to the oauth page
			resp.Error(w, http.StatusBadRequest, "Refresh token is expired")
			return
		}

		h.oauther.ServerToken.AccessToken = accessToken
		h.oauther.ServerToken.RefreshToken = refreshToken
		h.oauther.ServerToken.ExpirationRefreshToken = time.Time{}

		//check if the access token is found and valid
		if accessToken == "" || IsTokenExpired(true, accessToken, db) {
			//generate a new token pair
			err = h.oauther.GenerateNewTokenPairFromRefreshToken(db)
			if err != nil {
				resp.Error(w, http.StatusInternalServerError, err.Error())
				return
			}

			//generateNewTokenPairFromRefreshToken will also create a new oauther client
			//so we need to check if sheeter and calender structs are set, if not we set them
			if h.sheeter == nil || h.calender == nil {
				h.sheeter, err = NewSheeter(h.oauther.Client)
				if err != nil {
					fmt.Printf("error in sheeter function, creating new sheet: %v\n", err)
					resp.Errorf(w, http.StatusInternalServerError, "Error creating new sheeter: %v\n", err)
					return
				}
				handler.calender, err = NewCalender(h.oauther.Client)
				if err != nil {
					fmt.Printf("error in calender function, creating new sheet: %v\n", err)
					resp.Errorf(w, http.StatusInternalServerError, "Error creating new calender: %v\n", err)
					return
				}
			}

			//delete the old tokens from the cookies
			http.SetCookie(w, &http.Cookie{
				Name:    "accessToken",
				Path:    "/",
				Value:   "",
				Expires: time.Unix(0, 0),
			})
			http.SetCookie(w, &http.Cookie{
				Name:    "refreshToken",
				Path:    "/",
				Value:   "",
				Expires: time.Unix(0, 0),
			})

			//set the new tokens as cookie
			//!should set domain and path
			http.SetCookie(w, &http.Cookie{
				Name:    "accessToken",
				Path:    "/",
				Value:   h.oauther.ServerToken.AccessToken,
				Expires: time.Now().Add(time.Hour),
			})
			http.SetCookie(w, &http.Cookie{
				Name:    "refreshToken",
				Path:    "/",
				Value:   h.oauther.ServerToken.RefreshToken,
				Expires: time.Now().Add(time.Hour * 24 * 7),
			})
			//send the cookie to the client
		}

		//if the oauther client is nil then
		//this will set the oauther client and oauther tokens (google tokens)
		if h.oauther.Client == nil {
			if err := h.oauther.SetGoogleTokensFromAccessToken(db); err != nil {
				fmt.Printf("error getting the google tokens from access token: %v\n\n", err)
				resp.Errorf(w, http.StatusInternalServerError, "Error getting google tokens: %v", err)
				return
			}

			//set the handler sheet and calendar structs (they need a oauther client)
			if h.sheeter, err = NewSheeter(h.oauther.Client); err != nil {
				fmt.Printf("error creating new sheeter: %v\n", err)
				resp.Errorf(w, http.StatusInternalServerError, "Error creating new sheeter: %v", err)
				return
			}

			if handler.calender, err = NewCalender(h.oauther.Client); err != nil {
				fmt.Printf("error creating new calender: %v\n", err)
				resp.Errorf(w, http.StatusInternalServerError, "Error creating new calender: %v", err)
				return
			}
		}

		if h.oauther.UserInfo == nil {
			if err := h.oauther.GetUserInformation(); err != nil {
				fmt.Printf("error getting user informations: %v\n", err)
				resp.Errorf(w, http.StatusInternalServerError, "error getting user informations: %v", err)
				return
			}
		}

		//redirect to the actual handler
		next.ServeHTTP(w, r)
	})
}

//just used to log the user interactions with the server
func (h *HandlerHttp) loggerMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s %s %s\n", r.RemoteAddr, r.Method, r.URL)
		next.ServeHTTP(w, r)
	})
}

//!========== OAUTH HANDLERS

//generate the oauth url and redirect to it
func (h *HandlerHttp) OauthGoogleHandler(w http.ResponseWriter, r *http.Request) {
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v\n", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()
	url, err := h.oauther.GenerateOauthUrl(conn)
	if err != nil {
		fmt.Printf("error in oauther function, generating oauth url: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error generating oauth url: %v", err)
		return
	}

	//redirect the user to the url
	// http.Redirect(w, r, url, http.StatusFound)
	m := map[string]interface{}{"url": url}
	resp.SuccessMap(w, http.StatusOK, "you can login using this url", m)
}

//oauth callback handler
func (h *HandlerHttp) OauthGoogleCallbackHandler(w http.ResponseWriter, r *http.Request) {
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v\n", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()

	state := r.FormValue("state")
	code := r.FormValue("code")

	//validate the state and retrive the google code
	err = h.oauther.GetOauthCodeFromUrl(conn, code, state)
	if err != nil {
		fmt.Printf("error in oauther function, getting oauth code from url: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting oauth code from url: %v", err)
		return
	}

	//set the oauth google tokens
	if err := h.oauther.GetOauthTokenPairFromCode(conn); err != nil {
		fmt.Printf("error in oauther function, getting oauth token pair from code: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting oauth token pair from code: %v", err)
		return
	}

	if err := h.oauther.GetUserInformation(); err != nil {
		fmt.Printf("error in oauther function, getting user information: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting user information: %v", err)
		return
	}

	//set calender and sheeter client
	if h.sheeter, err = NewSheeter(h.oauther.Client); err != nil {
		fmt.Printf("error creating new sheeter: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error creating new sheeter: %v", err)
		return
	}
	if h.calender, err = NewCalender(h.oauther.Client); err != nil {
		fmt.Printf("error creating new calender: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error creating new calender: %v", err)
		return
	}
	if does, err := h.calender.DoesUserOwnCalendar(conn, h.oauther.UserInfo.Email); err != nil {
		fmt.Printf("error checking if user owns calendar: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error checking if user owns calendar: %v", err)
		return
	} else if !does {
		if err := h.calender.CreateNewCalendar(conn, h.oauther.UserInfo.Email, "Calendar Manager"); err != nil {
			fmt.Printf("error creating calendar: %v\n", err)
			resp.Errorf(w, http.StatusInternalServerError, "Error creating calendar: %v", err)
			return
		}
	}
	//generate the token pair, the email will be autoretrived by the function
	if err := h.oauther.GenerateTokensFromUserEmail(conn); err != nil {
		fmt.Printf("error in oauther function, generating tokens from user email: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error generating tokens from user email: %v", err)
		return
	}

	//set the cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "accessToken",
		Path:    "/",
		Value:   h.oauther.ServerToken.AccessToken,
		Expires: time.Now().Add(time.Minute * 15),
	})
	http.SetCookie(w, &http.Cookie{
		Name:    "refreshToken",
		Path:    "/",
		Value:   h.oauther.ServerToken.RefreshToken,
		Expires: time.Now().Add(time.Hour * 24 * 7),
	})

	http.Redirect(w, r, "/user/home", http.StatusFound)
	// json, err := json.Marshal(h.oauther.ServerToken)
	// if err != nil {
	// 	fmt.Printf("error in oauther function, marshaling server token: %v\n", err)
	// 	resp.Errorf(w, http.StatusInternalServerError, "Error marshaling server token: %v", err)
	// 	return
	// }
	// resp.SuccessJson(w, http.StatusOK, "Successfully authenticated", json)
}

//!========== SHEETS HANDLERS

//create a new sheet and return the sheet url
//if the name is not set it will assume a default value ("Calendar Manager Sheet")
func (h *HandlerHttp) CreateSheetHandler(w http.ResponseWriter, r *http.Request) {
	//get the name of the sheet from url query
	name := r.URL.Query().Get("name")
	if name == "" {
		name = "Calendar Manager Sheet"
	}

	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v\n", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()

	fmt.Println("is sheeter nil: ", h.sheeter == nil)

	err = h.sheeter.CreateNewSheet(conn, h.oauther.UserInfo.Email, name)
	if err != nil {
		fmt.Printf("error in sheeter function, creating new sheet: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error creating new sheet: %v", err)
		return
	}
	resp.SuccessMap(w, http.StatusOK, "Successfully created sheet", map[string]interface{}{
		"uri":  h.sheeter.SheetUri,
		"name": name,
	})
}

func (h *HandlerHttp) GetEventsHandler(w http.ResponseWriter, r *http.Request) {
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v\n", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()

	//get the events from the sheet
	err = h.sheeter.GetEventsFromSheet(conn, h.oauther.UserInfo.Email)
	if err != nil {
		fmt.Printf("error in sheeter function, getting events: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting events: %v", err)
		return
	}

	//convert the events to json
	json, err := json.Marshal(h.sheeter.Events)
	if err != nil {
		fmt.Printf("error in sheeter function, marshaling events: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error marshaling events: %v", err)
		return
	}

	resp.SuccessJson(w, http.StatusOK, "Successfully retrieved events", json)
}

//!========== CALENDAR HANDLERS

func (h *HandlerHttp) UpdateCalendarHandler(w http.ResponseWriter, r *http.Request) {
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v\n", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()

	if err := h.sheeter.GetEventsFromSheet(conn, h.oauther.UserInfo.Email); err != nil {
		fmt.Printf("error in sheeter function, getting events: %v\n", err)
		resp.Errorf(w, http.StatusBadRequest, "Error getting events: %v", err)
		return
	}

	h.calender.DoesUserOwnCalendar(conn, h.oauther.UserInfo.Email)

	if err := h.calender.UpdateCalendar(h.sheeter.Events); err != nil {
		fmt.Printf("error in calender function, updating calendar: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error updating calendar: %v", err)
		return
	}
	resp.Success(w, http.StatusOK, "Successfully updated calendar")
}

//!========== STATIC HANDLERS
func (h *HandlerHttp) LoginHandler(w http.ResponseWriter, r *http.Request) {
	var refreshToken string
	for _, cookie := range r.Cookies() {
		switch cookie.Name {
		case "refreshToken":
			refreshToken = cookie.Value
		}
	}

	if refreshToken != "" {
		//redirect to the homepage
		http.Redirect(w, r, "/user/home", http.StatusFound)
		return
	}

	//read the file static/pages/login.html
	file, err := ioutil.ReadFile("pages/login.html")
	if err != nil {
		fmt.Printf("error reading file: %v\n", err)
		resp.Error(w, http.StatusServiceUnavailable, "uh oh, looks like we have some problems getting what you want, dont worry it's on us though")
		return
	}
	//write the file to the response
	w.Write(file)
}

func (h *HandlerHttp) HomeHandler(w http.ResponseWriter, r *http.Request) {
	//read the file static/pages/home.html
	// file, err := ioutil.ReadFile("pages/home.html")
	// if err != nil {
	// 	fmt.Printf("error reading file: %v\n", err)
	// 	resp.Error(w, http.StatusServiceUnavailable, "uh oh, looks like we have some problems getting what you want, dont worry it's on us though")
	// 	return
	// }
	// //write the file to the response
	// w.Write(file)
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v\n", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()

	hasOne, err := h.sheeter.DoesUserOwnSheet(conn, h.oauther.UserInfo.Email)
	if err != nil {
		fmt.Printf("error in sheeter function, getting events: %v\n", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting events: %v", err)
		return
	}

	var funcName, buttString string
	if !hasOne {
		funcName = "createSheet()"
		buttString = "Crea Un Nuovo Foglio"
	} else {
		funcName = "updateCalendar()"
		buttString = "Aggiorna Il Calendario"
	}
	data := struct {
		Pfp      string
		Name     string
		Function string
		Button   string
	}{
		Pfp:      h.oauther.UserInfo.Picture,
		Name:     h.oauther.UserInfo.Name,
		Function: funcName,
		Button:   buttString,
	}

	tmpl, err := template.ParseFiles("pages/home.html")
	if err != nil {
		resp.Errorf(w, http.StatusServiceUnavailable, "error parsing the template: %v", err.Error())
		return
	}

	w.Header().Set("Content-Type", "text/html")
	tmpl.Execute(w, data)
}

//set the oauth google struct, sheets and tokens structs
func NewHandlerHttp(googleCredentialsFile string) (*HandlerHttp, error) {
	handler := new(HandlerHttp)
	var err error
	handler.oauther, err = NewOauther(googleCredentialsFile)
	if err != nil {
		return nil, err
	}
	return handler, nil
}
