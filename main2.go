package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"

	"github.com/gorilla/mux"
	resp "github.com/vano2903/calendarManager/responser"
	"golang.org/x/oauth2"
)

// Retrieve a token, saves the token, then returns the generated client.
func getClient(config *oauth2.Config) *http.Client {
	// The file token.json stores the user's access and refresh tokens, and is
	// created automatically when the authorization flow completes for the first
	// time.
	tokFile := "token.json"
	tok, err := tokenFromFile(tokFile)
	if err != nil {
		tok = getTokenFromWeb(config)
		saveToken(tokFile, tok)
	}

	return config.Client(context.Background(), tok)
}

// Request a token from the web, then returns the retrieved token.
func getTokenFromWeb(config *oauth2.Config) *oauth2.Token {
	authURL := config.AuthCodeURL("state-token", oauth2.AccessTypeOffline)
	fmt.Printf("premi l'url e, dopo aver verificato le varie cose copia il valore del parametro 'code': \n\n%v\n", authURL)
	var authCode string
	if _, err := fmt.Scan(&authCode); err != nil {
		log.Fatalf("Unable to read authorization code: %v", err)
	}

	// var url string

	// oauther, _ := NewOauther("clientgoogle.json")
	// fmt.Print("get function")
	// fmt.Println(oauther.GetOauthCodeFromUrl(url))

	tok, err := config.Exchange(context.TODO(), authCode)
	if err != nil {
		log.Fatalf("Unable to retrieve token from web: %v", err)
	}
	return tok
	// return nil
}

// Retrieves a token from a local file.
func tokenFromFile(file string) (*oauth2.Token, error) {
	f, err := os.Open(file)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	tok := &oauth2.Token{}
	err = json.NewDecoder(f).Decode(tok)
	return tok, err
}

// Saves a token to a file path.
func saveToken(path string, token *oauth2.Token) {
	fmt.Printf("Saving credential file to: %s\n", path)
	f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		log.Fatalf("Unable to cache oauth token: %v", err)
	}
	defer f.Close()
	json.NewEncoder(f).Encode(token)
}

const (
	googleCredentialsFile string = "clientgoogle.json"
)

var (
	oauther *Oauther
)

/*
this middleware validates if the users has a valid access token
what it does/check:
1) if the session is found
2) if the refresh token is found (if not it will redirect to the oauth server)
3) if the refresh token is expired
4) if the access token is found/valid, since this runs after the check of the refresh token
the middleware will generate a new pair of tokens if the access token is expired/not found and
save them in the session
5) if it pass all the check it will run the func given as parameter
!this middleware only validates the token pair generated by the server, not the google one
*/
func AccessTokenMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// get the access token and the refresh token from cookies
		var accessToken string
		var refreshToken string
		for _, cookie := range r.Cookies() {
			switch cookie.Name {
			case "accessToken":
				accessToken = cookie.Value
			case "refreshToken":
				refreshToken = cookie.Value
			}
		}

		//if refresh token is not found redirect to oauth endpoint
		if refreshToken == "" {
			resp.Error(w, http.StatusBadRequest, "No refresh token, you should visit the oauth page")
			return
		}

		//create a connection with the db
		db, err := connectToDB()
		if err != nil {
			resp.Error(w, http.StatusInternalServerError, err.Error())
			return
		}
		defer db.Close()

		//check if the refresh token is expired
		if IsTokenExpired(false, refreshToken, db) {
			//!should redirect to the oauth page
			resp.Error(w, http.StatusBadRequest, "Refresh token is expired")
			return
		}

		//check if the access token is found and valid
		if accessToken == "" || IsTokenExpired(true, accessToken, db) {
			//generate a new token pair
			err = oauther.GenerateNewTokenPairFromRefreshToken(db)
			if err != nil {
				resp.Error(w, http.StatusInternalServerError, err.Error())
				return
			}

			log.Println("generated new token pair")
			log.Println("access token:", oauther.ServerToken.AccessToken)
			log.Println("refresh token:", oauther.ServerToken.RefreshToken)

			//delete the old tokens from the cookies
			http.SetCookie(w, &http.Cookie{
				Name:    "accessToken",
				Path:    "/",
				Value:   "",
				Expires: time.Unix(0, 0),
			})
			http.SetCookie(w, &http.Cookie{
				Name:    "refreshToken",
				Path:    "/",
				Value:   "",
				Expires: time.Unix(0, 0),
			})

			//set the new tokens as cookie
			//!should set domain and path
			http.SetCookie(w, &http.Cookie{
				Name:    "accessToken",
				Path:    "/",
				Value:   oauther.ServerToken.AccessToken,
				Expires: time.Now().Add(time.Hour),
			})
			http.SetCookie(w, &http.Cookie{
				Name:    "refreshToken",
				Path:    "/",
				Value:   oauther.ServerToken.RefreshToken,
				Expires: time.Now().Add(time.Hour * 24 * 7),
			})
		}

		//redirect to the actual handler
		next.ServeHTTP(w, r)
	})
}

//just used to log the user interactions with the server
func loggerMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		log.Printf("%s %s %s\n", r.RemoteAddr, r.Method, r.URL)
		next.ServeHTTP(w, r)
	})
}

//generate the oauth url and redirect to it
func oauthGoogleHandler(w http.ResponseWriter, r *http.Request) {
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()
	url, err := oauther.GenerateOauthUrl(conn)
	if err != nil {
		fmt.Printf("error in oauther function, generating oauth url: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error generating oauth url: %v", err)
		return
	}

	//redirect the user to the url
	http.Redirect(w, r, url, http.StatusFound)
}

//oauth callback handler,
func oauthGoogleCallback(w http.ResponseWriter, r *http.Request) {
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()

	state := r.FormValue("state")
	code := r.FormValue("code")

	//validate the state and retrive the google code
	err = oauther.GetOauthCodeFromUrl(conn, code, state)
	if err != nil {
		fmt.Printf("error in oauther function, getting oauth code from url: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting oauth code from url: %v", err)
		return
	}

	//set the oauth google tokens
	if err := oauther.GetOauthTokenPairFromCode(conn); err != nil {
		fmt.Printf("error in oauther function, getting oauth token pair from code: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting oauth token pair from code: %v", err)
		return
	}

	//generate the token pair, the email will be autoretrived by the function
	if err := oauther.GenerateTokensFromUserEmail(conn); err != nil {
		fmt.Printf("error in oauther function, generating tokens from user email: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error generating tokens from user email: %v", err)
		return
	}

	//set the cookie
	http.SetCookie(w, &http.Cookie{
		Name:    "accessToken",
		Path:    "/",
		Value:   oauther.ServerToken.AccessToken,
		Expires: time.Now().Add(time.Minute * 15),
	})
	http.SetCookie(w, &http.Cookie{
		Name:    "refreshToken",
		Path:    "/",
		Value:   oauther.ServerToken.RefreshToken,
		Expires: time.Now().Add(time.Hour * 24 * 7),
	})

	json, err := json.Marshal(oauther.ServerToken)
	if err != nil {
		fmt.Printf("error in oauther function, marshaling server token: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error marshaling server token: %v", err)
		return
	}
	resp.SuccessJson(w, http.StatusOK, "Successfully authenticated", json)
}

func getUserInfoHandler(w http.ResponseWriter, r *http.Request) {
	conn, err := connectToDB()
	if err != nil {
		fmt.Printf("Error connecting to DB: %v", err)
		resp.Error(w, http.StatusInternalServerError, "Error connecting to DB")
		return
	}
	defer conn.Close()

	//get the token pair from cookies
	accessToken, err := r.Cookie("accessToken")
	if err != nil {
		resp.Errorf(w, http.StatusInternalServerError, "error getting the access token: %v", err)
		return
	}
	refreshToken, err := r.Cookie("refreshToken")
	if err != nil {
		resp.Errorf(w, http.StatusInternalServerError, "Error getting refresh token: %v", err)
		return
	}

	fmt.Println("accessToken: ", accessToken.Value)
	fmt.Println("refreshToken: ", refreshToken.Value)

	oauther.ServerToken.AccessToken = accessToken.Value
	oauther.ServerToken.RefreshToken = refreshToken.Value

	err = oauther.SetGoogleTokensFromAccessToken(conn)
	if err != nil {
		fmt.Printf("error in oauther function, setting google tokens from access token: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error setting google tokens from access token: %v", err)
		return
	}

	//get the user info
	err = oauther.GetUserInformation()
	if err != nil {
		fmt.Printf("error in oauther function, getting user info: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error getting user info: %v", err)
		return
	}

	//marshal the user info
	json, err := json.Marshal(oauther.UserInfo)
	if err != nil {
		fmt.Printf("error in oauther function, marshaling user info: %v", err)
		resp.Errorf(w, http.StatusInternalServerError, "Error marshaling user info: %v", err)
		return
	}
	resp.SuccessJson(w, http.StatusOK, "Successfully got user info", json)
}

func init() {
	var err error
	if oauther, err = NewOauther(googleCredentialsFile); err != nil {
		log.Fatal(err)
	}
}

func main() {
	r := mux.NewRouter()
	r.Use(loggerMiddleware)

	//serve static files
	r.PathPrefix("/").Handler(http.FileServer(http.Dir("./static/")))
	//!need to know the pages first
	// r.HandleFunc("/oauth", oauthGooglePageHandler).Methods("GET")

	api := r.PathPrefix("/api").Subrouter()
	api.Use(AccessTokenMiddleware)
	r.HandleFunc("/info", getUserInfoHandler).Methods("GET")

	oauth := r.PathPrefix("/auth").Subrouter()
	oauth.HandleFunc("/google/login", oauthGoogleHandler).Methods("GET")
	oauth.HandleFunc("/google/callback", oauthGoogleCallback).Methods("GET")

	fmt.Println("listening on port 8000")
	if err := http.ListenAndServe(":8000", r); err != nil {
		log.Fatal(err)
	}

	// info, err := oauth.NewUserinfoV2MeService(s).Get().Do()
	// if err != nil {
	// 	log.Fatalf("Unable to retrieve user info: %v", err)
	// }
	// fmt.Println("======INFO GENERALI======\n")

	// fmt.Println("======UTENTE INFO 1======")
	// fmt.Printf("email %q\n", info.Email)
	// fmt.Printf("family name %q\n", info.FamilyName)
	// fmt.Printf("gender %q\n", info.Gender)
	// fmt.Printf("given name %q\n", info.GivenName)
	// fmt.Printf("hosted domain %q\n", info.Hd)
	// fmt.Printf("ID %q\n", info.Id)
	// fmt.Printf("link %q\n", info.Link)
	// fmt.Printf("locale %q\n", info.Locale)
	// fmt.Printf("name %q\n", info.Name)
	// fmt.Printf("picure %q\n", info.Picture)
	// fmt.Printf("verified %v\n", *info.VerifiedEmail)

	// info2, err := s.Tokeninfo().Do()
	// if err != nil {
	// 	log.Fatalf("Unable to retrieve user info: %v", err)
	// }
	// fmt.Println("======UTENTE INFO 2 (inutile)======")
	// fmt.Printf("access_type %q\n", info2.AccessType)
	// fmt.Printf("audience %q\n", info2.Audience)
	// fmt.Printf("email %q\n", info2.Email)
	// fmt.Printf("verified_email %v\n", info2.VerifiedEmail)
	// fmt.Printf("email_verified %v\n", info2.EmailVerified)
	// fmt.Printf("expires_in %q\n", info2.ExpiresIn)
	// fmt.Printf("issued_at %q\n", info2.IssuedAt)
	// fmt.Printf("issued_to %q\n", info2.IssuedTo)
	// fmt.Printf("issuer %q\n", info2.Issuer)
	// fmt.Printf("nonce %q\n", info2.Nonce)
	// fmt.Printf("scope %q\n", info2.Scope)
	// fmt.Printf("user_id %q\n", info2.UserId)

	// srv, err := calendar.NewService(ctx, option.WithHTTPClient(client))
	// if err != nil {
	// 	log.Fatalf("Unable to retrieve Calendar client: %v", err)
	// }
	// srv.UserAgent = "calendar-manager-v1"
	// fmt.Println("\n\n======CALENDARS JSON======\n")
	// // fmt.Println("======EVENTS======")
	// // t := time.Now().Format(time.RFC3339)
	// // events, err := srv.Events.List("primary").ShowDeleted(true).SingleEvents(true).TimeMin(t).OrderBy("startTime").Do() //SingleEvents(true).TimeMin(t).MaxResults(10).
	// // if err != nil {
	// // 	log.Fatalf("Unable to retrieve next ten of the user's events: %v", err)
	// // }

	// // fmt.Println("Upcoming events:")
	// // if len(events.Items) == 0 {
	// // 	fmt.Println("No upcoming events found.")
	// // 	return
	// // }

	// // for _, item := range events.Items {
	// // 	date := item.Start.DateTime
	// // 	if date == "" {
	// // 		date = item.Start.Date
	// // 	}
	// // 	fmt.Printf("%v (%v)\n", item.Summary, date)
	// // }

	// //!googleapi.IsNotModified(err)
	// idk, err := srv.CalendarList.List().Do()
	// if err != nil {
	// 	log.Fatalf("Unable to retrieve Calendar List: %v", err)
	// }

	// fmt.Println("======CALENDAR LIST FIELDS======")

	// fmt.Println("calendar list etag", idk.Etag)
	// fmt.Println("calendar list next page token", idk.NextPageToken)
	// fmt.Println("calendar list next sync token", idk.NextSyncToken)

	// fmt.Println("======REMINDERS======")

	// for i, item := range idk.Items {
	// 	// fmt.Printf("%v (%v)\n", item.Summary, item.Id)
	// 	fmt.Printf("======ELEMENT %d======\n", i)

	// 	fmt.Println("======CONFERENCE======")
	// 	fmt.Println("Conference proprieties solution:", item.ConferenceProperties.AllowedConferenceSolutionTypes)

	// 	fmt.Println("\n======REMINDERS======")
	// 	if item.DefaultReminders != nil {
	// 		for _, reminder := range item.DefaultReminders {
	// 			fmt.Println("event reminder method:", reminder.Method)
	// 			fmt.Println("event reminder minutes:", reminder.Minutes)
	// 		}
	// 	} else {
	// 		fmt.Println("event reminder:", "NONE")
	// 	}

	// 	fmt.Println("\n======NOTIFICATION======")
	// 	if item.NotificationSettings != nil {
	// 		for _, notification := range item.NotificationSettings.Notifications {
	// 			fmt.Println("notification method:", notification.Method)
	// 			fmt.Println("notification Type:", notification.Type)
	// 		}
	// 	} else {
	// 		fmt.Println("event notification:", "NONE")
	// 	}

	// 	fmt.Println("\n======ITEM FIELD======")
	// 	fmt.Println("accessRole:", item.AccessRole)
	// 	fmt.Println("background color:", item.BackgroundColor)
	// 	fmt.Println("colorId:", item.ColorId)
	// 	fmt.Println("deleted:", item.Deleted)
	// 	fmt.Println("description:", item.Description)
	// 	fmt.Println("etag:", item.Etag)
	// 	fmt.Println("foreground color:", item.ForegroundColor)
	// 	fmt.Println("hidden:", item.Hidden)
	// 	fmt.Println("king:", item.Kind)
	// 	fmt.Println("location:", item.Location)
	// 	fmt.Println("primary:", item.Primary)
	// 	fmt.Println("selected:", item.Selected)
	// 	fmt.Println("summary:", item.Summary)
	// 	fmt.Println("summaryOverride:", item.SummaryOverride)
	// 	fmt.Println("timeZone:", item.TimeZone)
	// 	fmt.Println()
	// }
}

// func main() {
// 	ctx := context.Background()
// 	b, err := ioutil.ReadFile("clientgoogle.json")
// 	if err != nil {
// 		log.Fatalf("Unable to read client secret file: %v", err)
// 	}

// 	// If modifying these scopes, delete your previously saved token.json.
// 	config, err := google.ConfigFromJSON(b, calendar.CalendarScope, calendar.CalendarEventsScope, oauth.UserinfoProfileScope, oauth.UserinfoEmailScope, oauth.PlusMeScope)
// 	if err != nil {
// 		log.Fatalf("Unable to parse client secret file to config: %v", err)
// 	}
// 	client := getClient(config)

// 	s, err := oauth.NewService(ctx, option.WithHTTPClient(client))
// 	if err != nil {
// 		log.Fatalf("Unable to create OAuth client: %v", err)
// 	}

// 	info, err := oauth.NewUserinfoV2MeService(s).Get().Do()
// 	if err != nil {
// 		log.Fatalf("Unable to retrieve user info: %v", err)
// 	}
// 	fmt.Println("======INFO GENERALI======\n")

// 	fmt.Println("======UTENTE INFO 1======")
// 	fmt.Printf("email %q\n", info.Email)
// 	fmt.Printf("family name %q\n", info.FamilyName)
// 	fmt.Printf("gender %q\n", info.Gender)
// 	fmt.Printf("given name %q\n", info.GivenName)
// 	fmt.Printf("hosted domain %q\n", info.Hd)
// 	fmt.Printf("ID %q\n", info.Id)
// 	fmt.Printf("link %q\n", info.Link)
// 	fmt.Printf("locale %q\n", info.Locale)
// 	fmt.Printf("name %q\n", info.Name)
// 	fmt.Printf("picure %q\n", info.Picture)
// 	fmt.Printf("verified %v\n", *info.VerifiedEmail)

// 	info2, err := s.Tokeninfo().Do()
// 	if err != nil {
// 		log.Fatalf("Unable to retrieve user info: %v", err)
// 	}
// 	fmt.Println("======UTENTE INFO 2 (inutile)======")
// 	fmt.Printf("access_type %q\n", info2.AccessType)
// 	fmt.Printf("audience %q\n", info2.Audience)
// 	fmt.Printf("email %q\n", info2.Email)
// 	fmt.Printf("verified_email %v\n", info2.VerifiedEmail)
// 	fmt.Printf("email_verified %v\n", info2.EmailVerified)
// 	fmt.Printf("expires_in %q\n", info2.ExpiresIn)
// 	fmt.Printf("issued_at %q\n", info2.IssuedAt)
// 	fmt.Printf("issued_to %q\n", info2.IssuedTo)
// 	fmt.Printf("issuer %q\n", info2.Issuer)
// 	fmt.Printf("nonce %q\n", info2.Nonce)
// 	fmt.Printf("scope %q\n", info2.Scope)
// 	fmt.Printf("user_id %q\n", info2.UserId)

// 	srv, err := calendar.NewService(ctx, option.WithHTTPClient(client))
// 	if err != nil {
// 		log.Fatalf("Unable to retrieve Calendar client: %v", err)
// 	}
// 	srv.UserAgent = "calendar-manager-v1"
// 	fmt.Println("\n\n======CALENDARS JSON======\n")
// 	// fmt.Println("======EVENTS======")
// 	// t := time.Now().Format(time.RFC3339)
// 	// events, err := srv.Events.List("primary").ShowDeleted(true).SingleEvents(true).TimeMin(t).OrderBy("startTime").Do() //SingleEvents(true).TimeMin(t).MaxResults(10).
// 	// if err != nil {
// 	// 	log.Fatalf("Unable to retrieve next ten of the user's events: %v", err)
// 	// }

// 	// fmt.Println("Upcoming events:")
// 	// if len(events.Items) == 0 {
// 	// 	fmt.Println("No upcoming events found.")
// 	// 	return
// 	// }

// 	// for _, item := range events.Items {
// 	// 	date := item.Start.DateTime
// 	// 	if date == "" {
// 	// 		date = item.Start.Date
// 	// 	}
// 	// 	fmt.Printf("%v (%v)\n", item.Summary, date)
// 	// }

// 	//!googleapi.IsNotModified(err)
// 	idk, err := srv.CalendarList.List().Do()
// 	if err != nil {
// 		log.Fatalf("Unable to retrieve Calendar List: %v", err)
// 	}

// 	fmt.Println("======CALENDAR LIST FIELDS======")

// 	fmt.Println("calendar list etag", idk.Etag)
// 	fmt.Println("calendar list next page token", idk.NextPageToken)
// 	fmt.Println("calendar list next sync token", idk.NextSyncToken)

// 	fmt.Println("======REMINDERS======")

// 	for i, item := range idk.Items {
// 		// fmt.Printf("%v (%v)\n", item.Summary, item.Id)
// 		fmt.Printf("======ELEMENT %d======\n", i)

// 		fmt.Println("======CONFERENCE======")
// 		fmt.Println("Conference proprieties solution:", item.ConferenceProperties.AllowedConferenceSolutionTypes)

// 		fmt.Println("\n======REMINDERS======")
// 		if item.DefaultReminders != nil {
// 			for _, reminder := range item.DefaultReminders {
// 				fmt.Println("event reminder method:", reminder.Method)
// 				fmt.Println("event reminder minutes:", reminder.Minutes)
// 			}
// 		} else {
// 			fmt.Println("event reminder:", "NONE")
// 		}

// 		fmt.Println("\n======NOTIFICATION======")
// 		if item.NotificationSettings != nil {
// 			for _, notification := range item.NotificationSettings.Notifications {
// 				fmt.Println("notification method:", notification.Method)
// 				fmt.Println("notification Type:", notification.Type)
// 			}
// 		} else {
// 			fmt.Println("event notification:", "NONE")
// 		}

// 		fmt.Println("\n======ITEM FIELD======")
// 		fmt.Println("accessRole:", item.AccessRole)
// 		fmt.Println("background color:", item.BackgroundColor)
// 		fmt.Println("colorId:", item.ColorId)
// 		fmt.Println("deleted:", item.Deleted)
// 		fmt.Println("description:", item.Description)
// 		fmt.Println("etag:", item.Etag)
// 		fmt.Println("foreground color:", item.ForegroundColor)
// 		fmt.Println("hidden:", item.Hidden)
// 		fmt.Println("king:", item.Kind)
// 		fmt.Println("location:", item.Location)
// 		fmt.Println("primary:", item.Primary)
// 		fmt.Println("selected:", item.Selected)
// 		fmt.Println("summary:", item.Summary)
// 		fmt.Println("summaryOverride:", item.SummaryOverride)
// 		fmt.Println("timeZone:", item.TimeZone)
// 		fmt.Println()
// 	}
// }
